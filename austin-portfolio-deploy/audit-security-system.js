/**
 * Blaze Intelligence Audit Trails & Security Controls
 * Comprehensive logging, monitoring, and security enforcement
 */

class AuditSecuritySystem {
    constructor() {
        this.auditLog = [];
        this.securityEvents = [];
        this.sessionData = {
            sessionId: this.generateSessionId(),
            userId: this.getUserId(),
            startTime: Date.now(),
            userAgent: navigator.userAgent,
            ipHash: null,
            deviceFingerprint: null
        };
        
        this.securityRules = {
            rateLimiting: {
                api_calls: { window: 60000, limit: 100 },        // 100 calls per minute
                login_attempts: { window: 900000, limit: 5 },    // 5 attempts per 15 minutes
                data_exports: { window: 3600000, limit: 10 },    // 10 exports per hour
                ai_requests: { window: 60000, limit: 20 }        // 20 AI requests per minute
            },
            sessionSecurity: {
                maxSessionTime: 8 * 60 * 60 * 1000,             // 8 hours
                idleTimeout: 30 * 60 * 1000,                    // 30 minutes
                requireReauth: 4 * 60 * 60 * 1000,              // 4 hours for sensitive ops
                maxConcurrentSessions: 3\n            },\n            dataAccess: {\n                requireConsent: ['biometric', 'video', 'personal'],\n                encryptSensitive: ['biometric', 'payment', 'identity'],\n                auditSensitive: ['export', 'share', 'delete'],\n                retentionPeriods: {\n                    audit_logs: 7 * 365 * 24 * 60 * 60 * 1000,  // 7 years\n                    session_logs: 90 * 24 * 60 * 60 * 1000,     // 90 days\n                    error_logs: 30 * 24 * 60 * 60 * 1000,       // 30 days\n                    access_logs: 365 * 24 * 60 * 60 * 1000      // 1 year\n                }\n            }\n        };\n        \n        this.rateLimiters = new Map();\n        this.securityAlerts = [];\n        this.encryptionKey = null;\n        \n        this.init();\n    }\n    \n    async init() {\n        await this.initializeSession();\n        this.setupEventListeners();\n        this.startSecurityMonitoring();\n        this.scheduleCleanup();\n        this.loadAuditHistory();\n        \n        // Log system initialization\n        this.logAuditEvent({\n            action: 'system_init',\n            category: 'system',\n            details: {\n                version: '2.0',\n                features: ['audit_trails', 'security_controls', 'rate_limiting', 'encryption']\n            }\n        });\n        \n        console.log('🔒 Audit & Security system initialized');\n    }\n    \n    async initializeSession() {\n        // Generate device fingerprint\n        this.sessionData.deviceFingerprint = await this.generateDeviceFingerprint();\n        \n        // Hash IP address for privacy\n        this.sessionData.ipHash = await this.hashCurrentIP();\n        \n        // Initialize rate limiters\n        Object.keys(this.securityRules.rateLimiting).forEach(key => {\n            this.rateLimiters.set(key, []);\n        });\n        \n        // Generate encryption key for sensitive data\n        this.encryptionKey = await this.generateEncryptionKey();\n        \n        // Log session start\n        this.logAuditEvent({\n            action: 'session_start',\n            category: 'authentication',\n            details: {\n                sessionId: this.sessionData.sessionId,\n                deviceFingerprint: this.sessionData.deviceFingerprint.substring(0, 8) + '...',\n                userAgent: this.sessionData.userAgent.substring(0, 50) + '...'\n            }\n        });\n    }\n    \n    generateSessionId() {\n        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;\n    }\n    \n    getUserId() {\n        // Try to get user ID from various sources\n        return localStorage.getItem('user_id') || \n               sessionStorage.getItem('user_id') || \n               'anonymous_' + Math.random().toString(36).substr(2, 12);\n    }\n    \n    async generateDeviceFingerprint() {\n        const components = [\n            navigator.userAgent,\n            navigator.language,\n            screen.width + 'x' + screen.height,\n            screen.colorDepth,\n            new Date().getTimezoneOffset(),\n            navigator.hardwareConcurrency || 'unknown',\n            navigator.deviceMemory || 'unknown'\n        ];\n        \n        const fingerprint = components.join('|');\n        return await this.hashString(fingerprint);\n    }\n    \n    async hashCurrentIP() {\n        try {\n            const response = await fetch('https://api.ipify.org?format=json');\n            const data = await response.json();\n            return await this.hashString(data.ip + 'salt_blaze_2024');\n        } catch (error) {\n            return await this.hashString('unknown_ip_salt_blaze_2024');\n        }\n    }\n    \n    async hashString(str) {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(str);\n        const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 32);\n    }\n    \n    async generateEncryptionKey() {\n        return await crypto.subtle.generateKey(\n            { name: 'AES-GCM', length: 256 },\n            false, // not extractable\n            ['encrypt', 'decrypt']\n        );\n    }\n    \n    setupEventListeners() {\n        // DOM interactions\n        document.addEventListener('click', (e) => {\n            this.trackUserInteraction('click', e.target);\n        });\n        \n        document.addEventListener('keydown', (e) => {\n            // Log potentially sensitive key combinations\n            if (e.ctrlKey || e.metaKey) {\n                this.trackUserInteraction('keyboard_shortcut', e.target, {\n                    key: e.key,\n                    ctrl: e.ctrlKey,\n                    meta: e.metaKey\n                });\n            }\n        });\n        \n        // Form submissions\n        document.addEventListener('submit', (e) => {\n            this.trackFormSubmission(e.target);\n        });\n        \n        // Page visibility changes (potential security event)\n        document.addEventListener('visibilitychange', () => {\n            this.logAuditEvent({\n                action: document.hidden ? 'page_hidden' : 'page_visible',\n                category: 'navigation',\n                details: { timestamp: Date.now() }\n            });\n        });\n        \n        // Browser events that might indicate security issues\n        window.addEventListener('beforeunload', () => {\n            this.logAuditEvent({\n                action: 'session_end',\n                category: 'authentication',\n                details: {\n                    sessionDuration: Date.now() - this.sessionData.startTime,\n                    reason: 'page_unload'\n                }\n            });\n            this.flushAuditLogs();\n        });\n        \n        // Console access detection (potential security risk)\n        let devtools = { open: false, orientation: null };\n        const threshold = 160;\n        \n        setInterval(() => {\n            const heightThreshold = window.outerHeight - window.innerHeight > threshold;\n            const widthThreshold = window.outerWidth - window.innerWidth > threshold;\n            \n            if (!(heightThreshold && widthThreshold) && \n                ((window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized) ||\n                 heightThreshold || widthThreshold)) {\n                \n                if (!devtools.open) {\n                    devtools.open = true;\n                    this.logSecurityEvent({\n                        event: 'devtools_opened',\n                        severity: 'medium',\n                        details: {\n                            method: heightThreshold ? 'height_check' : 'width_check',\n                            timestamp: Date.now()\n                        }\n                    });\n                }\n            } else {\n                devtools.open = false;\n            }\n        }, 500);\n    }\n    \n    trackUserInteraction(type, element, extraData = {}) {\n        // Only log interactions with sensitive elements\n        const sensitiveSelectors = [\n            '.auth-form',\n            '.payment-form',\n            '.data-export',\n            '.admin-panel',\n            '.settings-panel',\n            '[data-sensitive]',\n            '.ai-controls'\n        ];\n        \n        const isSensitive = sensitiveSelectors.some(selector => {\n            try {\n                return element.matches && element.matches(selector);\n            } catch {\n                return false;\n            }\n        });\n        \n        if (isSensitive) {\n            this.logAuditEvent({\n                action: `user_interaction_${type}`,\n                category: 'user_activity',\n                details: {\n                    elementType: element.tagName?.toLowerCase(),\n                    elementId: element.id,\n                    elementClass: element.className?.substring(0, 50),\n                    ...extraData\n                },\n                sensitivity: 'medium'\n            });\n        }\n    }\n    \n    trackFormSubmission(form) {\n        const formId = form.id || 'unknown_form';\n        const formData = new FormData(form);\n        const fieldNames = Array.from(formData.keys());\n        \n        // Check for sensitive fields\n        const sensitiveFields = ['password', 'ssn', 'credit_card', 'biometric_data'];\n        const hasSensitiveData = fieldNames.some(field => \n            sensitiveFields.some(sensitive => field.toLowerCase().includes(sensitive))\n        );\n        \n        this.logAuditEvent({\n            action: 'form_submission',\n            category: 'data_input',\n            details: {\n                formId,\n                fieldCount: fieldNames.length,\n                fieldNames: fieldNames.map(name => this.sanitizeFieldName(name)),\n                hasSensitiveData\n            },\n            sensitivity: hasSensitiveData ? 'high' : 'low'\n        });\n    }\n    \n    sanitizeFieldName(fieldName) {\n        // Remove potentially sensitive info from field names\n        return fieldName.replace(/\\d/g, 'X').substring(0, 20);\n    }\n    \n    startSecurityMonitoring() {\n        // Check for suspicious activity every 30 seconds\n        setInterval(() => {\n            this.checkRateLimits();\n            this.checkSessionSecurity();\n            this.checkDataAccess();\n        }, 30000);\n        \n        // Check for session timeout every minute\n        setInterval(() => {\n            this.checkSessionTimeout();\n        }, 60000);\n        \n        // Security health check every 5 minutes\n        setInterval(() => {\n            this.runSecurityHealthCheck();\n        }, 300000);\n    }\n    \n    checkRateLimits() {\n        const now = Date.now();\n        \n        Object.entries(this.securityRules.rateLimiting).forEach(([action, rule]) => {\n            const attempts = this.rateLimiters.get(action) || [];\n            \n            // Clean old attempts\n            const validAttempts = attempts.filter(timestamp => now - timestamp < rule.window);\n            this.rateLimiters.set(action, validAttempts);\n            \n            // Check for violations\n            if (validAttempts.length > rule.limit) {\n                this.logSecurityEvent({\n                    event: 'rate_limit_violation',\n                    severity: 'high',\n                    details: {\n                        action,\n                        attempts: validAttempts.length,\n                        limit: rule.limit,\n                        window: rule.window\n                    }\n                });\n            }\n        });\n    }\n    \n    checkSessionSecurity() {\n        const now = Date.now();\n        const sessionAge = now - this.sessionData.startTime;\n        \n        // Check max session time\n        if (sessionAge > this.securityRules.sessionSecurity.maxSessionTime) {\n            this.logSecurityEvent({\n                event: 'session_expired',\n                severity: 'medium',\n                details: {\n                    sessionAge,\n                    maxAge: this.securityRules.sessionSecurity.maxSessionTime\n                }\n            });\n            \n            this.enforceSessionExpiry();\n        }\n        \n        // Check idle timeout\n        const lastActivity = this.getLastActivityTime();\n        if (lastActivity && (now - lastActivity) > this.securityRules.sessionSecurity.idleTimeout) {\n            this.logSecurityEvent({\n                event: 'session_idle_timeout',\n                severity: 'low',\n                details: {\n                    idleTime: now - lastActivity,\n                    timeout: this.securityRules.sessionSecurity.idleTimeout\n                }\n            });\n        }\n    }\n    \n    checkDataAccess() {\n        // Monitor for unusual data access patterns\n        const recentAudits = this.auditLog.filter(entry => \n            Date.now() - entry.timestamp < 300000 // Last 5 minutes\n        );\n        \n        // Check for rapid data exports\n        const exportEvents = recentAudits.filter(entry => \n            entry.action.includes('export') || entry.action.includes('download')\n        );\n        \n        if (exportEvents.length > 5) {\n            this.logSecurityEvent({\n                event: 'suspicious_data_access',\n                severity: 'high',\n                details: {\n                    exportCount: exportEvents.length,\n                    timeWindow: '5 minutes'\n                }\n            });\n        }\n        \n        // Check for access without consent\n        const sensitiveAccess = recentAudits.filter(entry => \n            entry.details?.dataType && \n            this.securityRules.dataAccess.requireConsent.includes(entry.details.dataType) &&\n            !entry.details?.consentVerified\n        );\n        \n        if (sensitiveAccess.length > 0) {\n            this.logSecurityEvent({\n                event: 'data_access_without_consent',\n                severity: 'critical',\n                details: {\n                    accessCount: sensitiveAccess.length,\n                    dataTypes: [...new Set(sensitiveAccess.map(e => e.details.dataType))]\n                }\n            });\n        }\n    }\n    \n    checkSessionTimeout() {\n        const lastActivity = this.getLastActivityTime();\n        const now = Date.now();\n        \n        if (lastActivity && (now - lastActivity) > this.securityRules.sessionSecurity.idleTimeout) {\n            this.enforceIdleTimeout();\n        }\n    }\n    \n    getLastActivityTime() {\n        try {\n            return parseInt(localStorage.getItem('blaze_last_activity')) || Date.now();\n        } catch {\n            return Date.now();\n        }\n    }\n    \n    updateLastActivity() {\n        try {\n            localStorage.setItem('blaze_last_activity', Date.now().toString());\n        } catch (error) {\n            console.warn('Failed to update last activity time:', error);\n        }\n    }\n    \n    runSecurityHealthCheck() {\n        const healthMetrics = {\n            auditLogSize: this.auditLog.length,\n            securityEventCount: this.securityEvents.length,\n            sessionAge: Date.now() - this.sessionData.startTime,\n            rateLimiterStatus: Object.fromEntries(\n                Array.from(this.rateLimiters.entries()).map(([key, attempts]) => [\n                    key, \n                    { attempts: attempts.length, lastAttempt: Math.max(...attempts, 0) }\n                ])\n            ),\n            alertCount: this.securityAlerts.length\n        };\n        \n        this.logAuditEvent({\n            action: 'security_health_check',\n            category: 'system',\n            details: healthMetrics\n        });\n        \n        // Check for issues\n        if (this.securityEvents.filter(e => e.severity === 'critical').length > 0) {\n            this.triggerSecurityAlert('Critical security events detected', 'critical');\n        }\n    }\n    \n    scheduleCleanup() {\n        // Clean old audit logs every hour\n        setInterval(() => {\n            this.cleanupAuditLogs();\n        }, 3600000);\n        \n        // Clean old security events daily\n        setInterval(() => {\n            this.cleanupSecurityEvents();\n        }, 86400000);\n        \n        // Initial cleanup\n        setTimeout(() => {\n            this.cleanupAuditLogs();\n            this.cleanupSecurityEvents();\n        }, 5000);\n    }\n    \n    cleanupAuditLogs() {\n        const now = Date.now();\n        const retentionPeriods = this.securityRules.dataAccess.retentionPeriods;\n        \n        // Separate logs by type and apply appropriate retention\n        const cleanedLogs = this.auditLog.filter(entry => {\n            const age = now - entry.timestamp;\n            \n            if (entry.category === 'system') {\n                return age < retentionPeriods.audit_logs;\n            } else if (entry.category === 'authentication') {\n                return age < retentionPeriods.session_logs;\n            } else if (entry.category === 'error') {\n                return age < retentionPeriods.error_logs;\n            } else {\n                return age < retentionPeriods.access_logs;\n            }\n        });\n        \n        const removedCount = this.auditLog.length - cleanedLogs.length;\n        this.auditLog = cleanedLogs;\n        \n        if (removedCount > 0) {\n            this.logAuditEvent({\n                action: 'audit_cleanup',\n                category: 'system',\n                details: {\n                    removedLogs: removedCount,\n                    remainingLogs: this.auditLog.length\n                }\n            });\n        }\n    }\n    \n    cleanupSecurityEvents() {\n        const cutoffTime = Date.now() - (30 * 24 * 60 * 60 * 1000); // 30 days\n        const oldCount = this.securityEvents.length;\n        \n        this.securityEvents = this.securityEvents.filter(\n            event => event.timestamp > cutoffTime\n        );\n        \n        const removedCount = oldCount - this.securityEvents.length;\n        \n        if (removedCount > 0) {\n            this.logAuditEvent({\n                action: 'security_event_cleanup',\n                category: 'system',\n                details: {\n                    removedEvents: removedCount,\n                    remainingEvents: this.securityEvents.length\n                }\n            });\n        }\n    }\n    \n    loadAuditHistory() {\n        try {\n            const stored = localStorage.getItem('blaze_audit_history');\n            if (stored) {\n                const history = JSON.parse(stored);\n                // Only load recent history (last 24 hours)\n                const cutoff = Date.now() - (24 * 60 * 60 * 1000);\n                this.auditLog = history.filter(entry => entry.timestamp > cutoff);\n            }\n        } catch (error) {\n            console.warn('Failed to load audit history:', error);\n        }\n    }\n    \n    enforceSessionExpiry() {\n        // Force logout and clear session\n        this.logAuditEvent({\n            action: 'forced_logout',\n            category: 'authentication',\n            details: {\n                reason: 'session_expired',\n                sessionAge: Date.now() - this.sessionData.startTime\n            },\n            severity: 'medium'\n        });\n        \n        this.clearSession();\n    }\n    \n    enforceIdleTimeout() {\n        this.logAuditEvent({\n            action: 'idle_timeout',\n            category: 'authentication',\n            details: {\n                idleTime: Date.now() - this.getLastActivityTime()\n            },\n            severity: 'low'\n        });\n        \n        this.showIdleTimeoutWarning();\n    }\n    \n    showIdleTimeoutWarning() {\n        const warning = document.createElement('div');\n        warning.className = 'idle-timeout-warning';\n        warning.innerHTML = `\n            <div class=\"timeout-content\">\n                <h3>⏰ Session Timeout Warning</h3>\n                <p>Your session will expire soon due to inactivity.</p>\n                <div class=\"timeout-actions\">\n                    <button class=\"extend-session\">Continue Session</button>\n                    <button class=\"logout-now\">Logout Now</button>\n                </div>\n            </div>\n            <div class=\"timeout-backdrop\"></div>\n        `;\n        \n        // Style the warning\n        const style = document.createElement('style');\n        style.textContent = `\n            .idle-timeout-warning {\n                position: fixed;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 0;\n                z-index: 10000;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n            }\n            \n            .timeout-backdrop {\n                position: absolute;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 0;\n                background: rgba(0, 0, 0, 0.8);\n                z-index: -1;\n            }\n            \n            .timeout-content {\n                background: #1a1a1a;\n                border: 2px solid #FF6B6B;\n                border-radius: 8px;\n                padding: 24px;\n                text-align: center;\n                color: white;\n                max-width: 400px;\n            }\n            \n            .timeout-content h3 {\n                color: #FF6B6B;\n                margin: 0 0 12px 0;\n            }\n            \n            .timeout-actions {\n                display: flex;\n                gap: 12px;\n                margin-top: 20px;\n            }\n            \n            .timeout-actions button {\n                flex: 1;\n                padding: 10px;\n                border: none;\n                border-radius: 4px;\n                font-weight: 600;\n                cursor: pointer;\n            }\n            \n            .extend-session {\n                background: #4CAF50;\n                color: white;\n            }\n            \n            .logout-now {\n                background: #FF6B6B;\n                color: white;\n            }\n        `;\n        \n        document.head.appendChild(style);\n        document.body.appendChild(warning);\n        \n        // Handle actions\n        warning.querySelector('.extend-session').addEventListener('click', () => {\n            this.updateLastActivity();\n            warning.remove();\n            style.remove();\n        });\n        \n        warning.querySelector('.logout-now').addEventListener('click', () => {\n            this.clearSession();\n            warning.remove();\n            style.remove();\n        });\n        \n        // Auto-logout after 60 seconds if no action\n        setTimeout(() => {\n            if (document.body.contains(warning)) {\n                this.clearSession();\n                warning.remove();\n                style.remove();\n            }\n        }, 60000);\n    }\n    \n    clearSession() {\n        // Clear all session data\n        try {\n            localStorage.removeItem('auth_token');\n            localStorage.removeItem('user_id');\n            localStorage.removeItem('blaze_last_activity');\n            sessionStorage.clear();\n            \n            // Redirect to login or home page\n            window.location.href = '/?session_expired=true';\n        } catch (error) {\n            console.error('Failed to clear session:', error);\n        }\n    }\n    \n    triggerSecurityAlert(message, severity) {\n        const alert = {\n            id: Date.now().toString(),\n            message,\n            severity,\n            timestamp: Date.now(),\n            resolved: false\n        };\n        \n        this.securityAlerts.push(alert);\n        \n        // Log the alert\n        this.logSecurityEvent({\n            event: 'security_alert_triggered',\n            severity,\n            details: { message, alertId: alert.id }\n        });\n        \n        // Show user notification for critical alerts\n        if (severity === 'critical') {\n            this.showSecurityAlert(alert);\n        }\n        \n        console.warn(`🚨 Security Alert [${severity.toUpperCase()}]: ${message}`);\n    }\n    \n    showSecurityAlert(alert) {\n        const notification = document.createElement('div');\n        notification.className = 'security-alert-notification';\n        notification.innerHTML = `\n            <div class=\"alert-content\">\n                <span class=\"alert-icon\">🚨</span>\n                <div class=\"alert-details\">\n                    <strong>Security Alert</strong>\n                    <p>${alert.message}</p>\n                </div>\n                <button class=\"alert-dismiss\" onclick=\"this.parentElement.parentElement.remove()\">×</button>\n            </div>\n        `;\n        \n        // Style the notification\n        notification.style.cssText = `\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: rgba(255, 107, 107, 0.95);\n            color: white;\n            padding: 16px;\n            border-radius: 8px;\n            border: 2px solid #FF6B6B;\n            z-index: 10000;\n            max-width: 400px;\n            animation: slideInRight 0.3s ease;\n        `;\n        \n        document.body.appendChild(notification);\n        \n        // Auto-dismiss after 10 seconds\n        setTimeout(() => {\n            if (notification.parentElement) {\n                notification.remove();\n            }\n        }, 10000);\n    }\n    \n    // Public API methods\n    \n    logAuditEvent(eventData) {\n        const auditEntry = {\n            id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),\n            timestamp: Date.now(),\n            sessionId: this.sessionData.sessionId,\n            userId: this.sessionData.userId,\n            action: eventData.action,\n            category: eventData.category || 'general',\n            details: eventData.details || {},\n            sensitivity: eventData.sensitivity || 'low',\n            userAgent: this.sessionData.userAgent,\n            ipHash: this.sessionData.ipHash,\n            deviceFingerprint: this.sessionData.deviceFingerprint\n        };\n        \n        this.auditLog.push(auditEntry);\n        \n        // Store in localStorage (with size limit)\n        this.persistAuditLogs();\n        \n        // Send to backend if available\n        this.sendAuditToBackend(auditEntry);\n        \n        // Update last activity\n        this.updateLastActivity();\n        \n        return auditEntry.id;\n    }\n    \n    logSecurityEvent(eventData) {\n        const securityEvent = {\n            id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),\n            timestamp: Date.now(),\n            sessionId: this.sessionData.sessionId,\n            event: eventData.event,\n            severity: eventData.severity || 'low',\n            details: eventData.details || {},\n            resolved: false\n        };\n        \n        this.securityEvents.push(securityEvent);\n        \n        // Also log as audit event\n        this.logAuditEvent({\n            action: `security_${eventData.event}`,\n            category: 'security',\n            details: eventData.details,\n            sensitivity: 'high'\n        });\n        \n        return securityEvent.id;\n    }\n    \n    logDataAccess(dataType, operation, details = {}) {\n        // Check if consent is required\n        const requiresConsent = this.securityRules.dataAccess.requireConsent.includes(dataType);\n        const hasConsent = window.blazePrivacy ? window.blazePrivacy.hasConsent(dataType) : false;\n        \n        const auditId = this.logAuditEvent({\n            action: `data_${operation}`,\n            category: 'data_access',\n            details: {\n                dataType,\n                operation,\n                requiresConsent,\n                consentVerified: hasConsent,\n                ...details\n            },\n            sensitivity: this.securityRules.dataAccess.encryptSensitive.includes(dataType) ? 'high' : 'medium'\n        });\n        \n        // Check if this is a sensitive operation that should be audited\n        if (this.securityRules.dataAccess.auditSensitive.includes(operation)) {\n            this.logSecurityEvent({\n                event: 'sensitive_data_operation',\n                severity: 'medium',\n                details: {\n                    dataType,\n                    operation,\n                    auditId,\n                    consentStatus: hasConsent\n                }\n            });\n        }\n        \n        return auditId;\n    }\n    \n    trackRateLimitedAction(action) {\n        if (!this.rateLimiters.has(action)) {\n            console.warn(`Unknown rate limited action: ${action}`);\n            return false;\n        }\n        \n        const now = Date.now();\n        const attempts = this.rateLimiters.get(action);\n        const rule = this.securityRules.rateLimiting[action];\n        \n        // Clean old attempts\n        const validAttempts = attempts.filter(timestamp => now - timestamp < rule.window);\n        \n        // Check if limit would be exceeded\n        if (validAttempts.length >= rule.limit) {\n            this.logSecurityEvent({\n                event: 'rate_limit_exceeded',\n                severity: 'medium',\n                details: {\n                    action,\n                    attempts: validAttempts.length,\n                    limit: rule.limit\n                }\n            });\n            \n            return false; // Action blocked\n        }\n        \n        // Record the attempt\n        validAttempts.push(now);\n        this.rateLimiters.set(action, validAttempts);\n        \n        return true; // Action allowed\n    }\n    \n    async encryptSensitiveData(data) {\n        if (!this.encryptionKey) {\n            throw new Error('Encryption key not available');\n        }\n        \n        const encoder = new TextEncoder();\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        const encodedData = encoder.encode(JSON.stringify(data));\n        \n        const encryptedBuffer = await crypto.subtle.encrypt(\n            { name: 'AES-GCM', iv },\n            this.encryptionKey,\n            encodedData\n        );\n        \n        return {\n            encrypted: Array.from(new Uint8Array(encryptedBuffer)),\n            iv: Array.from(iv)\n        };\n    }\n    \n    async decryptSensitiveData(encryptedData) {\n        if (!this.encryptionKey) {\n            throw new Error('Encryption key not available');\n        }\n        \n        const iv = new Uint8Array(encryptedData.iv);\n        const encrypted = new Uint8Array(encryptedData.encrypted);\n        \n        const decryptedBuffer = await crypto.subtle.decrypt(\n            { name: 'AES-GCM', iv },\n            this.encryptionKey,\n            encrypted\n        );\n        \n        const decoder = new TextDecoder();\n        const decryptedText = decoder.decode(decryptedBuffer);\n        \n        return JSON.parse(decryptedText);\n    }\n    \n    persistAuditLogs() {\n        try {\n            // Keep only recent logs in localStorage (last 1000 entries)\n            const recentLogs = this.auditLog.slice(-1000);\n            localStorage.setItem('blaze_audit_history', JSON.stringify(recentLogs));\n        } catch (error) {\n            console.warn('Failed to persist audit logs:', error);\n        }\n    }\n    \n    sendAuditToBackend(auditEntry) {\n        // Send to backend API if available\n        if (typeof fetch !== 'undefined') {\n            fetch('/api/audit', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(auditEntry)\n            }).catch(error => {\n                console.warn('Failed to send audit to backend:', error);\n            });\n        }\n    }\n    \n    flushAuditLogs() {\n        // Force save all audit logs\n        this.persistAuditLogs();\n        \n        // Send any unsent logs to backend\n        if (this.auditLog.length > 0) {\n            this.auditLog.forEach(entry => {\n                if (!entry.sent) {\n                    this.sendAuditToBackend(entry);\n                    entry.sent = true;\n                }\n            });\n        }\n    }\n    \n    // Getters for monitoring\n    getAuditLogs(category = null, limit = 100) {\n        let logs = category ? \n            this.auditLog.filter(log => log.category === category) : \n            this.auditLog;\n        \n        return logs\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n    \n    getSecurityEvents(severity = null, limit = 50) {\n        let events = severity ? \n            this.securityEvents.filter(event => event.severity === severity) : \n            this.securityEvents;\n        \n        return events\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n    \n    getSecuritySummary() {\n        return {\n            totalAuditEvents: this.auditLog.length,\n            totalSecurityEvents: this.securityEvents.length,\n            criticalEvents: this.securityEvents.filter(e => e.severity === 'critical').length,\n            sessionAge: Date.now() - this.sessionData.startTime,\n            activeAlerts: this.securityAlerts.filter(a => !a.resolved).length,\n            rateLimitViolations: this.securityEvents.filter(e => e.event.includes('rate_limit')).length\n        };\n    }\n}\n\n// Initialize global audit & security system\nwindow.blazeAudit = new AuditSecuritySystem();\n\n// Export for Node.js environment\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = AuditSecuritySystem;\n}\n\nconsole.log('🔒 Audit & Security system active - all activities monitored');