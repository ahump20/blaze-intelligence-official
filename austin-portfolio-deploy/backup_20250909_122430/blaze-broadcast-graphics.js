/**
 * Blaze Intelligence - Broadcast Quality Motion Graphics
 * ESPN "Willy Wonka of Graphics" philosophy with Texas heritage
 * Morphing scoreboards and signature transitions
 */

class BlazeBroadcastGraphics {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.animations = new Map();
        this.activeGraphics = new Map();
        this.isInitialized = false;
        
        // Broadcast-quality styling\n        this.broadcastPalette = {\n            primary: '#BF5700',         // Burnt Orange Heritage\n            secondary: '#9BCBEB',       // Cardinal Sky Blue\n            accent: '#00B2A9',          // Vancouver Teal\n            gold: '#FFD700',            // Championship Gold\n            silver: '#C0C0C0',          // Silver\n            white: '#FFFFFF',\n            black: '#000000',\n            warning: '#FF4444',         // Alert Red\n            success: '#00FF88'          // Success Green\n        };\n        \n        // Motion graphics settings\n        this.animationSettings = {\n            duration: 800,              // Signature transition time\n            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)', // Smooth broadcast easing\n            morphSpeed: 400,            // Morphing scoreboard speed\n            glowIntensity: 0.8,         // Championship glow effect\n            perspectiveDepth: 1000      // 3D perspective depth\n        };\n        \n        // Signature effects library\n        this.effects = {\n            championshipGlow: new ChampionshipGlowEffect(this),\n            morphingScoreboard: new MorphingScoreboardEffect(this),\n            pressureWave: new PressureWaveEffect(this),\n            clutchSpotlight: new ClutchSpotlightEffect(this),\n            momentumFlow: new MomentumFlowEffect(this),\n            texasFlare: new TexasFlareEffect(this)\n        };\n        \n        this.initialize();\n        console.log('📺 Broadcast Graphics System ready - Championship-quality visuals active');\n    }\n    \n    initialize() {\n        this.setupBroadcastCanvas();\n        this.initializeEffects();\n        this.bindBroadcastEvents();\n        this.startBroadcastLoop();\n        this.isInitialized = true;\n    }\n    \n    setupBroadcastCanvas() {\n        this.canvas = document.createElement('canvas');\n        this.canvas.id = 'blaze-broadcast-graphics';\n        this.canvas.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100vw;\n            height: 100vh;\n            pointer-events: none;\n            z-index: 2000;\n            opacity: 0;\n            transition: opacity 0.5s ease;\n        `;\n        \n        // 4K-ready canvas for broadcast quality\n        const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance\n        this.canvas.width = window.innerWidth * dpr;\n        this.canvas.height = window.innerHeight * dpr;\n        this.canvas.style.width = window.innerWidth + 'px';\n        this.canvas.style.height = window.innerHeight + 'px';\n        \n        this.ctx = this.canvas.getContext('2d');\n        this.ctx.scale(dpr, dpr);\n        \n        // Enable advanced rendering\n        this.ctx.imageSmoothingEnabled = true;\n        this.ctx.imageSmoothingQuality = 'high';\n        \n        document.body.appendChild(this.canvas);\n    }\n    \n    initializeEffects() {\n        Object.values(this.effects).forEach(effect => {\n            if (effect.initialize) {\n                effect.initialize();\n            }\n        });\n    }\n    \n    bindBroadcastEvents() {\n        // Listen for high-pressure moments for dramatic effects\n        if (window.blazePressureDataAdapter) {\n            window.blazePressureDataAdapter.onHighPressureEvent((data) => {\n                this.triggerChampionshipMoment(data);\n            });\n        }\n        \n        // Window resize handling\n        window.addEventListener('resize', this.handleResize.bind(this));\n    }\n    \n    startBroadcastLoop() {\n        const render = (currentTime) => {\n            this.renderBroadcastGraphics(currentTime);\n            requestAnimationFrame(render);\n        };\n        \n        requestAnimationFrame(render);\n    }\n    \n    renderBroadcastGraphics(currentTime) {\n        // Clear canvas with alpha for layered effects\n        this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        \n        // Render active effects in broadcast order\n        this.activeGraphics.forEach((graphic, id) => {\n            if (graphic.isActive && graphic.render) {\n                graphic.render(this.ctx, currentTime);\n            }\n        });\n    }\n    \n    // Signature broadcast effects\n    \n    triggerChampionshipMoment(data) {\n        console.log('🏆 Championship moment triggered:', data.description);\n        \n        // Show canvas for dramatic effect\n        this.canvas.style.opacity = '1';\n        \n        // Championship glow effect\n        this.effects.championshipGlow.trigger({\n            intensity: data.pressureIndex,\n            position: { x: window.innerWidth / 2, y: window.innerHeight / 2 },\n            duration: 2000\n        });\n        \n        // Pressure wave from center\n        this.effects.pressureWave.trigger({\n            center: { x: window.innerWidth / 2, y: window.innerHeight / 2 },\n            intensity: data.pressureIndex,\n            color: this.broadcastPalette.accent\n        });\n        \n        // Texas heritage flare\n        setTimeout(() => {\n            this.effects.texasFlare.trigger({\n                style: 'championship',\n                duration: 1500\n            });\n        }, 500);\n        \n        // Auto-hide after effect\n        setTimeout(() => {\n            this.canvas.style.opacity = '0';\n        }, 3000);\n    }\n    \n    showMorphingScoreboard(scoreData) {\n        this.canvas.style.opacity = '0.9';\n        \n        this.effects.morphingScoreboard.update(scoreData);\n        \n        // Auto-hide after 5 seconds\n        setTimeout(() => {\n            this.canvas.style.opacity = '0';\n        }, 5000);\n    }\n    \n    showClutchSpotlight(playerData) {\n        this.canvas.style.opacity = '0.8';\n        \n        this.effects.clutchSpotlight.focus(playerData);\n        \n        setTimeout(() => {\n            this.canvas.style.opacity = '0';\n        }, 4000);\n    }\n    \n    handleResize() {\n        const dpr = Math.min(window.devicePixelRatio || 1, 2);\n        this.canvas.width = window.innerWidth * dpr;\n        this.canvas.height = window.innerHeight * dpr;\n        this.canvas.style.width = window.innerWidth + 'px';\n        this.canvas.style.height = window.innerHeight + 'px';\n        this.ctx.scale(dpr, dpr);\n    }\n    \n    dispose() {\n        if (this.canvas && this.canvas.parentNode) {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n        \n        this.activeGraphics.clear();\n        this.animations.clear();\n        \n        console.log('📺 Broadcast Graphics System disposed');\n    }\n}\n\n// Broadcast Effect Classes\n\nclass ChampionshipGlowEffect {\n    constructor(parent) {\n        this.parent = parent;\n        this.isActive = false;\n        this.startTime = 0;\n        this.config = {};\n    }\n    \n    trigger(config) {\n        this.config = config;\n        this.isActive = true;\n        this.startTime = Date.now();\n        \n        this.parent.activeGraphics.set('championshipGlow', this);\n    }\n    \n    render(ctx, currentTime) {\n        if (!this.isActive) return;\n        \n        const elapsed = currentTime - this.startTime;\n        const progress = elapsed / this.config.duration;\n        \n        if (progress >= 1) {\n            this.isActive = false;\n            this.parent.activeGraphics.delete('championshipGlow');\n            return;\n        }\n        \n        // Pulsing championship glow\n        const intensity = Math.sin(progress * Math.PI * 4) * this.config.intensity;\n        const alpha = (1 - progress) * 0.8;\n        \n        // Create radial gradient\n        const gradient = ctx.createRadialGradient(\n            this.config.position.x, this.config.position.y, 0,\n            this.config.position.x, this.config.position.y, 300\n        );\n        \n        gradient.addColorStop(0, `rgba(191, 87, 0, ${alpha * intensity})`);\n        gradient.addColorStop(0.5, `rgba(155, 203, 235, ${alpha * intensity * 0.5})`);\n        gradient.addColorStop(1, 'rgba(0, 178, 169, 0)');\n        \n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);\n        \n        // Championship sparkles\n        for (let i = 0; i < 20; i++) {\n            const sparkleX = this.config.position.x + (Math.random() - 0.5) * 400;\n            const sparkleY = this.config.position.y + (Math.random() - 0.5) * 400;\n            const sparkleAlpha = Math.random() * alpha;\n            \n            ctx.fillStyle = `rgba(255, 215, 0, ${sparkleAlpha})`;\n            ctx.beginPath();\n            ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n}\n\nclass MorphingScoreboardEffect {\n    constructor(parent) {\n        this.parent = parent;\n        this.isActive = false;\n        this.currentData = null;\n        this.targetData = null;\n        this.morphProgress = 0;\n    }\n    \n    update(scoreData) {\n        this.currentData = this.targetData || scoreData;\n        this.targetData = scoreData;\n        this.morphProgress = 0;\n        this.isActive = true;\n        \n        this.parent.activeGraphics.set('morphingScoreboard', this);\n    }\n    \n    render(ctx, currentTime) {\n        if (!this.isActive || !this.targetData) return;\n        \n        // Smooth morphing animation\n        this.morphProgress += 0.05;\n        if (this.morphProgress >= 1) {\n            this.morphProgress = 1;\n            this.currentData = this.targetData;\n        }\n        \n        // Interpolated values\n        const homeScore = this.lerp(\n            this.currentData?.homeScore || 0,\n            this.targetData.homeScore,\n            this.morphProgress\n        );\n        \n        const awayScore = this.lerp(\n            this.currentData?.awayScore || 0,\n            this.targetData.awayScore,\n            this.morphProgress\n        );\n        \n        // Broadcast-style scoreboard\n        this.renderScoreboard(ctx, {\n            homeScore: Math.round(homeScore),\n            awayScore: Math.round(awayScore),\n            ...this.targetData\n        });\n    }\n    \n    renderScoreboard(ctx, data) {\n        const centerX = window.innerWidth / 2;\n        const centerY = 80;\n        const width = 400;\n        const height = 80;\n        \n        // Scoreboard background with Texas heritage styling\n        const gradient = ctx.createLinearGradient(centerX - width/2, centerY, centerX + width/2, centerY + height);\n        gradient.addColorStop(0, 'rgba(0, 34, 68, 0.95)');\n        gradient.addColorStop(1, 'rgba(26, 26, 26, 0.95)');\n        \n        ctx.fillStyle = gradient;\n        ctx.roundRect(centerX - width/2, centerY, width, height, 8);\n        ctx.fill();\n        \n        // Border with championship glow\n        ctx.strokeStyle = this.parent.broadcastPalette.primary;\n        ctx.lineWidth = 3;\n        ctx.shadowColor = this.parent.broadcastPalette.primary;\n        ctx.shadowBlur = 10;\n        ctx.roundRect(centerX - width/2, centerY, width, height, 8);\n        ctx.stroke();\n        ctx.shadowBlur = 0;\n        \n        // Team scores\n        ctx.fillStyle = this.parent.broadcastPalette.white;\n        ctx.font = 'bold 32px JetBrains Mono';\n        ctx.textAlign = 'center';\n        \n        // Home team\n        ctx.fillText(\n            data.homeTeam || 'HOME',\n            centerX - 120,\n            centerY + 25\n        );\n        \n        ctx.fillText(\n            data.homeScore.toString(),\n            centerX - 120,\n            centerY + 55\n        );\n        \n        // Away team\n        ctx.fillText(\n            data.awayTeam || 'AWAY',\n            centerX + 120,\n            centerY + 25\n        );\n        \n        ctx.fillText(\n            data.awayScore.toString(),\n            centerX + 120,\n            centerY + 55\n        );\n        \n        // Game clock\n        ctx.font = 'bold 16px JetBrains Mono';\n        ctx.fillText(\n            data.clock || '00:00',\n            centerX,\n            centerY + 35\n        );\n        \n        // Period/Quarter\n        ctx.font = '12px JetBrains Mono';\n        ctx.fillText(\n            data.period || 'Q1',\n            centerX,\n            centerY + 55\n        );\n    }\n    \n    lerp(start, end, progress) {\n        return start + (end - start) * progress;\n    }\n}\n\nclass PressureWaveEffect {\n    constructor(parent) {\n        this.parent = parent;\n        this.waves = [];\n    }\n    \n    trigger(config) {\n        this.waves.push({\n            center: config.center,\n            intensity: config.intensity,\n            color: config.color,\n            startTime: Date.now(),\n            duration: 2000\n        });\n        \n        this.parent.activeGraphics.set('pressureWave', this);\n    }\n    \n    render(ctx, currentTime) {\n        this.waves = this.waves.filter(wave => {\n            const elapsed = currentTime - wave.startTime;\n            const progress = elapsed / wave.duration;\n            \n            if (progress >= 1) return false;\n            \n            const radius = progress * 500;\n            const alpha = (1 - progress) * wave.intensity;\n            \n            ctx.strokeStyle = `rgba(191, 87, 0, ${alpha})`;\n            ctx.lineWidth = 4;\n            ctx.beginPath();\n            ctx.arc(wave.center.x, wave.center.y, radius, 0, Math.PI * 2);\n            ctx.stroke();\n            \n            return true;\n        });\n        \n        if (this.waves.length === 0) {\n            this.parent.activeGraphics.delete('pressureWave');\n        }\n    }\n}\n\nclass ClutchSpotlightEffect {\n    constructor(parent) {\n        this.parent = parent;\n        this.isActive = false;\n        this.spotlightData = null;\n        this.startTime = 0;\n    }\n    \n    focus(playerData) {\n        this.spotlightData = playerData;\n        this.isActive = true;\n        this.startTime = Date.now();\n        \n        this.parent.activeGraphics.set('clutchSpotlight', this);\n    }\n    \n    render(ctx, currentTime) {\n        if (!this.isActive) return;\n        \n        const elapsed = currentTime - this.startTime;\n        if (elapsed > 4000) {\n            this.isActive = false;\n            this.parent.activeGraphics.delete('clutchSpotlight');\n            return;\n        }\n        \n        // Spotlight effect\n        const centerX = window.innerWidth / 2;\n        const centerY = window.innerHeight / 2;\n        \n        // Create spotlight gradient\n        const gradient = ctx.createRadialGradient(\n            centerX, centerY, 0,\n            centerX, centerY, 300\n        );\n        \n        gradient.addColorStop(0, 'rgba(155, 203, 235, 0.3)');\n        gradient.addColorStop(0.7, 'rgba(155, 203, 235, 0.1)');\n        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');\n        \n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);\n        \n        // Player name in spotlight\n        ctx.fillStyle = this.parent.broadcastPalette.white;\n        ctx.font = 'bold 48px JetBrains Mono';\n        ctx.textAlign = 'center';\n        ctx.fillText(\n            this.spotlightData.name || 'CLUTCH PERFORMER',\n            centerX,\n            centerY - 20\n        );\n        \n        // Clutch stats\n        ctx.font = 'bold 24px JetBrains Mono';\n        ctx.fillText(\n            `CLUTCH RATING: ${this.spotlightData.clutchRating || '9.2'}`,\n            centerX,\n            centerY + 30\n        );\n    }\n}\n\nclass MomentumFlowEffect {\n    constructor(parent) {\n        this.parent = parent;\n        this.particles = [];\n    }\n    \n    initialize() {\n        // Initialize momentum particles\n    }\n    \n    render(ctx, currentTime) {\n        // Render flowing momentum particles\n    }\n}\n\nclass TexasFlareEffect {\n    constructor(parent) {\n        this.parent = parent;\n        this.isActive = false;\n        this.startTime = 0;\n        this.config = {};\n    }\n    \n    trigger(config) {\n        this.config = config;\n        this.isActive = true;\n        this.startTime = Date.now();\n        \n        this.parent.activeGraphics.set('texasFlare', this);\n    }\n    \n    render(ctx, currentTime) {\n        if (!this.isActive) return;\n        \n        const elapsed = currentTime - this.startTime;\n        const progress = elapsed / this.config.duration;\n        \n        if (progress >= 1) {\n            this.isActive = false;\n            this.parent.activeGraphics.delete('texasFlare');\n            return;\n        }\n        \n        // Texas-inspired star burst\n        const centerX = window.innerWidth / 2;\n        const centerY = window.innerHeight / 2;\n        const alpha = (1 - progress) * 0.8;\n        \n        for (let i = 0; i < 8; i++) {\n            const angle = (i / 8) * Math.PI * 2;\n            const length = progress * 200;\n            \n            ctx.strokeStyle = `rgba(191, 87, 0, ${alpha})`;\n            ctx.lineWidth = 6;\n            ctx.beginPath();\n            ctx.moveTo(centerX, centerY);\n            ctx.lineTo(\n                centerX + Math.cos(angle) * length,\n                centerY + Math.sin(angle) * length\n            );\n            ctx.stroke();\n        }\n    }\n}\n\n// Utility function for rounded rectangles\nif (typeof CanvasRenderingContext2D.prototype.roundRect === 'undefined') {\n    CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {\n        this.beginPath();\n        this.moveTo(x + radius, y);\n        this.lineTo(x + width - radius, y);\n        this.quadraticCurveTo(x + width, y, x + width, y + radius);\n        this.lineTo(x + width, y + height - radius);\n        this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n        this.lineTo(x + radius, y + height);\n        this.quadraticCurveTo(x, y + height, x, y + height - radius);\n        this.lineTo(x, y + radius);\n        this.quadraticCurveTo(x, y, x + radius, y);\n        this.closePath();\n    };\n}\n\n// Initialize and make globally available\nwindow.BlazeBroadcastGraphics = BlazeBroadcastGraphics;\n\nconsole.log('📺 Broadcast Graphics System loaded - Championship-quality motion graphics ready');